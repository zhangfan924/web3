<h1 align="center">区块链理论 / 以太坊</h1>

<p align="center">
  <img src="https://img.shields.io/badge/Markdown-模板-blue.svg" />
  <img src="https://img.shields.io/badge/Version-1.0-green.svg" />
</p>

# 📚区块链理论 / 以太坊

## 🔹 账户模型（Account-Based Ledger）

账户模型是以太坊等区块链系统常用的一种账本设计方式：

### 1️⃣ 基本概念

- **每个账户**都有一个 **唯一标识**（通常是公钥或地址）和一个 **余额**。
- **交易操作**直接修改账户余额：
  - 例：A 向 B 转账 10 ETH
    - A 的余额减少 10
    - B 的余额增加 10

------

### 2️⃣ 防止重放攻击（Replay Attack）

重放攻击指攻击者重复提交同一笔交易，试图多次转移资产。

#### 防护机制

1. **交易序号（Nonce）**
   - 每个账户的交易都有一个递增的序号 `nonce`。
   - 节点记录账户的最新 `nonce`，保证交易只能按顺序执行。
2. **数字签名保护**
   - 发送方对交易和 nonce 进行签名，确保交易不可篡改。
3. **交易验证**
   - 节点收到交易时，检查交易的 nonce 是否与账户当前值匹配：
     - 如果 nonce 已执行过 → 拒绝交易
     - 如果 nonce 正确 → 执行交易并更新 nonce

#### 示例

- A 当前 nonce = 20
- 交易：A → B 10 ETH，nonce = 21
- 节点接收交易，执行成功，nonce 更新为 21
- 攻击者重放这笔交易，nonce = 21 已使用 → 节点拒绝执行

## 🔹 账户类型（Ethereum 账户模型）

以太坊账户分为两类：**外部账户（EOA）** 和 **合约账户（Contract Account）**

------

### 1️⃣ 外部账户（Externally Owned Account, EOA）

- **控制方式**：由公私钥对控制
  - 拥有私钥的人可签署交易并控制账户资金
- **属性**：
  - **余额（Balance）**：存储 ETH 数量
  - **Nonce**：交易编号，用于防止重放攻击
- **特点**：
  - 可以发起交易（转账或调用合约）
  - 不包含智能合约代码

------

### 2️⃣ 合约账户（Contract Account）

- **控制方式**：没有私钥，无法自主发起交易
- **属性**：
  - **Nonce**：交易编号，用于合约创建和调用序列化
  - **Code**：存储智能合约的字节码
  - **Storage**：合约状态存储（键值对形式）
- **特点**：
  - 只能被外部账户或其他合约账户调用
  - 发起交易需要外部账户触发
  - 用于执行智能合约逻辑和维护状态

## 🌳 账户状态树（为什么不用 Hash 结构？）

### ✅ 如果只考虑性能和实现简单性

哈希表（HashMap）确实是一个直观选择：

- **O(1)** 的查找与插入性能
- 账户地址作为 `key`，账户状态作为 `value`
- 实现简单，代码容易维护

------

### ❌ 但问题在于 —— 缺乏“可验证性”

以太坊需要的不只是**本地查询快**，而是能**对全网证明状态正确性**。

- 轻节点（Light Client）只下载区块头，不保存完整状态数据

- 他们需要依赖全节点提供状态信息

- 如果仅用 HashMap，全节点只能回答：

  > “我查了一下表，余额是 100 ETH。”

- 轻节点无法验证这个答案是否篡改过，因为 HashMap 没有 **可验证路径**

------

### 🔑 区块链的需求：可验证性

在区块头里只存一个 **状态根（State Root）**，它是整棵状态树的根哈希。

- 任何账户状态的变更，都会改变根哈希
- 只要给出从根到某个叶子节点的**路径（Merkle Proof）**，轻节点就能验证这个状态确实存在于该区块的全网状态中
- 这样，全节点就无法随便“编造”一个余额来骗轻节点

------

### 🌟 举例说明

轻节点（钱包）问全节点：

> “账户 `0xabc` 的余额是多少？”

全节点回答：

> “100 ETH，并且给你一条 Merkle Proof。”

轻节点验证步骤：

1. 用这条路径从叶子计算到根
2. 对比结果是否等于区块头里的 `stateRoot`
3. 如果一致，就证明“100 ETH”是**真实可信**的

------

### 📌 总结

- **HashMap**：查询快，但不可验证
- **状态树（Merkle Patricia Trie）**：查询稍慢，但能证明数据的真实性，满足区块链的去信任需求

## 📘 账户状态树 —— 为什么不用普通 Merkle Tree？

### 1. 普通 Merkle Tree 的局限

- ❌ **查询困难**：没有按 `key` 查找的机制，查账户需要遍历。
- ❌ **更新低效**：修改或新增账户，可能导致大部分节点哈希值变化。

------

### 2. 如果采用 Merkle Tree，为什么必须排序？

- ✅ **保证一致性**：无序存储会导致不同节点构建的树结构不同，Merkle Root 不一致 → 无法达成共识。
- ✅ **证明“不存在”**：在有序结构中，可以用“前后邻居”来证明账户不存在；无序结构无法证明。

------

### 3. 新增账户的问题

- 新账户插入到中间位置时，后续所有节点的哈希值都会受影响。
- 更新代价过高，全网同步成本大。

------

## 📘 账户状态树 —— 为什么不用普通 Trie 结构？

### (1) ❌ 没有哈希验证能力

- 节点只是前缀字符，缺少哈希字段。
- 无法：
  - 生成全局一致的根哈希（`stateRoot`）。
  - 从某个值追溯到根的可验证路径（Merkle Proof）。

------

### (2) ❌ 存储空间过大

- 以太坊账户地址：`160 bits = 20 字节`。

- 如果按字节展开，每层一个字符：

  ```
  0xabc123...  ->  40 层深度
  ```

- 导致树很深，占用存储空间。

------

### (3) ❌ 不适合状态更新和删除

- 每次插入/更新，可能影响大量节点。
- 没有哈希缓存，无法高效更新 `stateRoot`。
- 删除操作也会导致大量结构重组。

采用Merkle Patricia Trie（MPT）

它融合了：

- 普通前缀树（Trie）
- Merkle Tree（默克尔树，支持哈希验证）
- Patricia Tree（压缩路径优化）

extension node代表该节点出现了路径压缩

根hash写在header里，是为了【防篡改，让轻节点也能验证状态是否正确，统一所有轻节点】

## 🌳 账户状态树 —— 为什么采用 **Merkle Patricia Trie（MPT）**

### 1. 设计目标

以太坊需要的数据结构必须同时满足：

- ✅ **快速查询 / 更新**（支持账户和存储的频繁变更）
- ✅ **可验证性**（轻节点也能验证账户状态）
- ✅ **存储高效**（避免巨大的稀疏树结构）

因此采用 **MPT**，融合了三种结构：

#### （1）Trie（前缀树）

- 以账户地址作为路径，自然支持 **键值映射**。
- 查询、插入、删除都很方便。

#### （2）Merkle Tree（默克尔树）

- 节点存储哈希，能得到全局唯一的 **根哈希**（`stateRoot`）。
- 提供 **Merkle Proof**：证明账户存在/不存在，以及账户余额是否正确。

#### （3）Patricia Tree（路径压缩树）

- 压缩稀疏路径，减少树高度。
- 地址 160 位（20 字节）理论上需 40 层（16 进制），实际非常稀疏。
- 通过路径压缩节省存储空间。

![MPT树](D:\study\web3\img\MPT树.png)

------

### 2. MPT 的节点类型

- **Branch Node（分支节点）**：
   最多 16 个子节点 + 1 个 value。
- **Extension Node（扩展节点）**：
   压缩路径，表示连续的相同前缀。
- **Leaf Node（叶子节点）**：
   存放最终值（如账户状态）。

------

### 3. 关键特性

- **`stateRoot` 写入区块头**
  - 确保状态防篡改。
  - 轻节点只需区块头 + Merkle Proof，就能验证账户状态。
- **高效更新**
  - 更新时只改 **从叶子到根的一条路径**。
  - 不需要重建整棵树。

------

### ✅ 总结

**MPT = Trie（路径存储） + Merkle（哈希验证） + Patricia（路径压缩）**
 👉 完美解决了以太坊 **存储、验证、更新** 的三大核心问题。

---

## ❓ 为什么账户树是 **全量的**，而不是每个区块只存本区块的状态？

### 1. 交易需要依赖账户的历史状态

- 例如：A 转账给 B
  - 需要读取 **A 的余额、nonce**。
  - 需要读取 **B 的账户信息**。
- 如果 B 是新建账户，就必须一路追溯到 **创世区块**，才能确认是否存在。

### 2. 账户状态是持续变化的

- 在区块 **A**：某账户的余额或 nonce 发生了更新。
- 到区块 **B**：该账户可能再次参与交易。
- 👉 所以必须 **继承并记录前一区块的完整状态**，才能确保链上每一步都正确。

### 3. 全量账户树的意义

- 任何时刻都能直接获取账户的最新状态。
- 轻节点通过 `stateRoot` + Merkle Proof 即可验证。
- 避免反复追溯历史交易，大幅提升效率。

## 📦 两个区块场景下的 MPT 状态存储

### 1. 区块的状态树是“共享 + 局部修改”

- 每个区块都会有自己的 **MPT（Merkle Patricia Trie）**。
- 但 **大部分节点是公用的**，只对发生变化的账户路径新建节点。
- 👉 这样避免每个区块都重新复制全量账户状态，节省存储空间。

------

### 2. 为什么要在 `stateRoot` 维护历史状态，而不是直接覆盖？

- 如果直接覆盖，旧的状态就 **丢失** 了。
- 以太坊 **12 秒一个区块**，分叉和回滚非常常见。
- 节点需要根据历史状态快速切换到另一条链。
- 👉 通过 `stateRoot`，可以随时回到 **任意区块的状态快照**。

------

### 3. 历史状态的作用

- **分叉回滚**：如果链上出现分叉，需要丢弃错误分支，回到分叉点的状态。
- **轻节点验证**：轻节点只存区块头，通过 `stateRoot + Merkle Proof` 验证账户余额等状态是否正确。
- **审计与追溯**：任意时刻都能重现链上某个区块时的全局状态。

![两个区块的MPT](img\两个区块的MPT.png)

## 交易树（Transaction Trie） & 收据树（Receipt Trie）

### 🌳 交易树

- **内容**：当前区块中所有交易的列表。
- **结构**：Merkle Patricia Trie（MPT），键为交易在区块中的索引（0,1,2…），值为交易本身的 RLP 编码。
- **特点**：
  - 每个区块都有自己的交易树，只记录该区块交易。
  - 便于轻节点验证交易是否被打包。
- **限制**：
  - 无法直接查询历史交易（如过去10天与某智能合约相关的所有交易）。

------

### 🌳 收据树

- **内容**：每笔交易执行后的收据（Receipt）。
- **收据包含**：
  - 交易执行状态（成功/失败）
  - Gas 消耗
  - 日志（logs，事件记录）
- **结构**：与交易树一一对应，键为交易索引。
- **功能**：
  - 轻节点可以验证某笔交易的执行结果或事件是否发生。
  - 支撑 DApp 的事件订阅机制。

------

### 🔄 关系与特性

- **一一对应**：交易树的第 N 笔交易对应收据树的第 N 个收据。
- **状态驱动**：每笔交易执行后，会驱动账户状态的变化（状态树更新），类似状态机的操作。
- **查询方式**：只能根据交易在区块中的索引查找，无法跨区块、跨时间查询历史交易或事件。

布隆过滤器

每个交易完成会有一个收据，收据里面有布隆过滤，记录交易类型，地址信息

发布区块的块头也有个总的布隆过滤器，该区块所有交易的布隆过滤器并集

查询过去10天中，所有跟某个智能合约有关的交易

查询哪个区块块头的布隆过滤器有我要的信息

查询区块里面交易的收据树的布隆过滤器

查到对应的交易

布隆过滤器的执行过程：

布隆过滤器包含一个位数组（bit array）和一组哈希函数（hash functions）。它的基本原理如下：

1. 初始化位数组：假设我们有一个大小为 m 的位数组，所有的位初始值都为 0。
2. 添加元素：
   - 对于每个要添加的元素，布隆过滤器通过多次哈希运算，将元素映射到数组中的多个位置（每个哈希函数对应一个位置）。
   - 每个哈希函数会返回一个整数，然后将该整数映射到位数组中的一个位置，并将该位置的值设置为 1。
   - 这些位置的值被设置为 1，表示该元素可能存在。
3. 验证元素是否存在：
   - 对于要检查的元素，布隆过滤器使用相同的哈希函数集进行哈希运算。
   - 如果所有对应的位在位数组中都为 1，则可以认为元素可能存在于集合中。
   - 如果有任何一个对应的位是 0，则可以确定该元素不在集合中。

## 布隆过滤器（Bloom Filter）

布隆过滤器是一种高效的概率型数据结构，用于检测某个元素是否可能存在于集合中。以太坊中，用于快速查找与特定智能合约或地址相关的交易。

------

### 🔹 在以太坊中的应用

1. **交易收据包含布隆过滤器**
   - 每笔交易执行完成后生成一个收据（Receipt）。
   - 收据中有布隆过滤器，用于记录交易相关的**事件、地址、合约调用信息**。
2. **区块头的总布隆过滤器**
   - 区块头中包含该区块所有交易布隆过滤器的**并集**。
   - 可以快速判断某个区块是否可能包含与特定地址或合约相关的交易。
3. **查询历史交易**
   - 查询过去10天中某个智能合约的相关交易：
     1. 检查区块头的布隆过滤器，看是否可能包含目标合约或地址。
     2. 若匹配，再查该区块内交易收据树的布隆过滤器。
     3. 定位到对应的交易及其收据。

------

### 🔹 布隆过滤器原理

1. **初始化位数组**
   - 假设有大小为 `m` 的位数组，初始所有位为 `0`。
2. **添加元素**
   - 对每个元素使用多组哈希函数（`k` 个哈希函数）。
   - 每个哈希函数生成一个整数，映射到位数组中的某个位置，将该位设为 `1`。
   - 多个哈希函数对应的位置都被置为 `1`，表示元素可能存在。
3. **验证元素是否存在**
   - 对要验证的元素，使用相同哈希函数计算对应位置。
   - **如果所有位都是 `1`** → 元素可能存在（存在误报的可能）。
   - **如果有任意一位为 `0`** → 元素**一定不存在**。

------

### 🔹 特性

- **高效**：比直接扫描交易或事件快得多。
- **节省空间**：用固定大小位数组记录大量元素。
- **允许误报**：可能提示元素存在但实际不存在，但**不会漏报**。
- **不可删除单个元素**：普通布隆过滤器无法删除元素（可用计数型布隆过滤器解决）。