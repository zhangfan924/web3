<h1 align="center">区块链理论 / 以太坊</h1>

<p align="center">
  <img src="https://img.shields.io/badge/Markdown-模板-blue.svg" />
  <img src="https://img.shields.io/badge/Version-1.0-green.svg" />
</p>

# 📚区块链理论 / 以太坊

## 🔹 账户模型（Account-Based Ledger）

账户模型是以太坊等区块链系统常用的一种账本设计方式：

### 1️⃣ 基本概念

- **每个账户**都有一个 **唯一标识**（通常是公钥或地址）和一个 **余额**。
- **交易操作**直接修改账户余额：
  - 例：A 向 B 转账 10 ETH
    - A 的余额减少 10
    - B 的余额增加 10

------

### 2️⃣ 防止重放攻击（Replay Attack）

重放攻击指攻击者重复提交同一笔交易，试图多次转移资产。

#### 防护机制

1. **交易序号（Nonce）**
   - 每个账户的交易都有一个递增的序号 `nonce`。
   - 节点记录账户的最新 `nonce`，保证交易只能按顺序执行。
2. **数字签名保护**
   - 发送方对交易和 nonce 进行签名，确保交易不可篡改。
3. **交易验证**
   - 节点收到交易时，检查交易的 nonce 是否与账户当前值匹配：
     - 如果 nonce 已执行过 → 拒绝交易
     - 如果 nonce 正确 → 执行交易并更新 nonce

#### 示例

- A 当前 nonce = 20
- 交易：A → B 10 ETH，nonce = 21
- 节点接收交易，执行成功，nonce 更新为 21
- 攻击者重放这笔交易，nonce = 21 已使用 → 节点拒绝执行

## 🔹 账户类型（Ethereum 账户模型）

以太坊账户分为两类：**外部账户（EOA）** 和 **合约账户（Contract Account）**

------

### 1️⃣ 外部账户（Externally Owned Account, EOA）

- **控制方式**：由公私钥对控制
  - 拥有私钥的人可签署交易并控制账户资金
- **属性**：
  - **余额（Balance）**：存储 ETH 数量
  - **Nonce**：交易编号，用于防止重放攻击
- **特点**：
  - 可以发起交易（转账或调用合约）
  - 不包含智能合约代码

------

### 2️⃣ 合约账户（Contract Account）

- **控制方式**：没有私钥，无法自主发起交易
- **属性**：
  - **Nonce**：交易编号，用于合约创建和调用序列化
  - **Code**：存储智能合约的字节码
  - **Storage**：合约状态存储（键值对形式）
- **特点**：
  - 只能被外部账户或其他合约账户调用
  - 发起交易需要外部账户触发
  - 用于执行智能合约逻辑和维护状态

## 🌳 账户状态树（为什么不用 Hash 结构？）

### ✅ 如果只考虑性能和实现简单性

哈希表（HashMap）确实是一个直观选择：

- **O(1)** 的查找与插入性能
- 账户地址作为 `key`，账户状态作为 `value`
- 实现简单，代码容易维护

------

### ❌ 但问题在于 —— 缺乏“可验证性”

以太坊需要的不只是**本地查询快**，而是能**对全网证明状态正确性**。

- 轻节点（Light Client）只下载区块头，不保存完整状态数据

- 他们需要依赖全节点提供状态信息

- 如果仅用 HashMap，全节点只能回答：

  > “我查了一下表，余额是 100 ETH。”

- 轻节点无法验证这个答案是否篡改过，因为 HashMap 没有 **可验证路径**

------

### 🔑 区块链的需求：可验证性

在区块头里只存一个 **状态根（State Root）**，它是整棵状态树的根哈希。

- 任何账户状态的变更，都会改变根哈希
- 只要给出从根到某个叶子节点的**路径（Merkle Proof）**，轻节点就能验证这个状态确实存在于该区块的全网状态中
- 这样，全节点就无法随便“编造”一个余额来骗轻节点

------

### 🌟 举例说明

轻节点（钱包）问全节点：

> “账户 `0xabc` 的余额是多少？”

全节点回答：

> “100 ETH，并且给你一条 Merkle Proof。”

轻节点验证步骤：

1. 用这条路径从叶子计算到根
2. 对比结果是否等于区块头里的 `stateRoot`
3. 如果一致，就证明“100 ETH”是**真实可信**的

------

### 📌 总结

- **HashMap**：查询快，但不可验证
- **状态树（Merkle Patricia Trie）**：查询稍慢，但能证明数据的真实性，满足区块链的去信任需求

## 📘 账户状态树 —— 为什么不用普通 Merkle Tree？

### 1. 普通 Merkle Tree 的局限

- ❌ **查询困难**：没有按 `key` 查找的机制，查账户需要遍历。
- ❌ **更新低效**：修改或新增账户，可能导致大部分节点哈希值变化。

------

### 2. 如果采用 Merkle Tree，为什么必须排序？

- ✅ **保证一致性**：无序存储会导致不同节点构建的树结构不同，Merkle Root 不一致 → 无法达成共识。
- ✅ **证明“不存在”**：在有序结构中，可以用“前后邻居”来证明账户不存在；无序结构无法证明。

------

### 3. 新增账户的问题

- 新账户插入到中间位置时，后续所有节点的哈希值都会受影响。
- 更新代价过高，全网同步成本大。

------

## 📘 账户状态树 —— 为什么不用普通 Trie 结构？

### (1) ❌ 没有哈希验证能力

- 节点只是前缀字符，缺少哈希字段。
- 无法：
  - 生成全局一致的根哈希（`stateRoot`）。
  - 从某个值追溯到根的可验证路径（Merkle Proof）。

------

### (2) ❌ 存储空间过大

- 以太坊账户地址：`160 bits = 20 字节`。

- 如果按字节展开，每层一个字符：

  ```
  0xabc123...  ->  40 层深度
  ```

- 导致树很深，占用存储空间。

------

### (3) ❌ 不适合状态更新和删除

- 每次插入/更新，可能影响大量节点。
- 没有哈希缓存，无法高效更新 `stateRoot`。
- 删除操作也会导致大量结构重组。

采用Merkle Patricia Trie（MPT）

它融合了：

- 普通前缀树（Trie）
- Merkle Tree（默克尔树，支持哈希验证）
- Patricia Tree（压缩路径优化）

extension node代表该节点出现了路径压缩

根hash写在header里，是为了【防篡改，让轻节点也能验证状态是否正确，统一所有轻节点】

## 🌳 账户状态树 —— 为什么采用 **Merkle Patricia Trie（MPT）**

### 1. 设计目标

以太坊需要的数据结构必须同时满足：

- ✅ **快速查询 / 更新**（支持账户和存储的频繁变更）
- ✅ **可验证性**（轻节点也能验证账户状态）
- ✅ **存储高效**（避免巨大的稀疏树结构）

因此采用 **MPT**，融合了三种结构：

#### （1）Trie（前缀树）

- 以账户地址作为路径，自然支持 **键值映射**。
- 查询、插入、删除都很方便。

#### （2）Merkle Tree（默克尔树）

- 节点存储哈希，能得到全局唯一的 **根哈希**（`stateRoot`）。
- 提供 **Merkle Proof**：证明账户存在/不存在，以及账户余额是否正确。

#### （3）Patricia Tree（路径压缩树）

- 压缩稀疏路径，减少树高度。
- 地址 160 位（20 字节）理论上需 40 层（16 进制），实际非常稀疏。
- 通过路径压缩节省存储空间。

![MPT树](D:\study\web3\img\MPT树.png)

------

### 2. MPT 的节点类型

- **Branch Node（分支节点）**：
   最多 16 个子节点 + 1 个 value。
- **Extension Node（扩展节点）**：
   压缩路径，表示连续的相同前缀。
- **Leaf Node（叶子节点）**：
   存放最终值（如账户状态）。

------

### 3. 关键特性

- **`stateRoot` 写入区块头**
  - 确保状态防篡改。
  - 轻节点只需区块头 + Merkle Proof，就能验证账户状态。
- **高效更新**
  - 更新时只改 **从叶子到根的一条路径**。
  - 不需要重建整棵树。

------

### ✅ 总结

**MPT = Trie（路径存储） + Merkle（哈希验证） + Patricia（路径压缩）**
 👉 完美解决了以太坊 **存储、验证、更新** 的三大核心问题。

---

## ❓ 为什么账户树是 **全量的**，而不是每个区块只存本区块的状态？

### 1. 交易需要依赖账户的历史状态

- 例如：A 转账给 B
  - 需要读取 **A 的余额、nonce**。
  - 需要读取 **B 的账户信息**。
- 如果 B 是新建账户，就必须一路追溯到 **创世区块**，才能确认是否存在。

### 2. 账户状态是持续变化的

- 在区块 **A**：某账户的余额或 nonce 发生了更新。
- 到区块 **B**：该账户可能再次参与交易。
- 👉 所以必须 **继承并记录前一区块的完整状态**，才能确保链上每一步都正确。

### 3. 全量账户树的意义

- 任何时刻都能直接获取账户的最新状态。
- 轻节点通过 `stateRoot` + Merkle Proof 即可验证。
- 避免反复追溯历史交易，大幅提升效率。

## 📦 两个区块场景下的 MPT 状态存储

### 1. 区块的状态树是“共享 + 局部修改”

- 每个区块都会有自己的 **MPT（Merkle Patricia Trie）**。
- 但 **大部分节点是公用的**，只对发生变化的账户路径新建节点。
- 👉 这样避免每个区块都重新复制全量账户状态，节省存储空间。

------

### 2. 为什么要在 `stateRoot` 维护历史状态，而不是直接覆盖？

- 如果直接覆盖，旧的状态就 **丢失** 了。
- 以太坊 **12 秒一个区块**，分叉和回滚非常常见。
- 节点需要根据历史状态快速切换到另一条链。
- 👉 通过 `stateRoot`，可以随时回到 **任意区块的状态快照**。

------

### 3. 历史状态的作用

- **分叉回滚**：如果链上出现分叉，需要丢弃错误分支，回到分叉点的状态。
- **轻节点验证**：轻节点只存区块头，通过 `stateRoot + Merkle Proof` 验证账户余额等状态是否正确。
- **审计与追溯**：任意时刻都能重现链上某个区块时的全局状态。

![两个区块的MPT](img\两个区块的MPT.png)

## 交易树（Transaction Trie） & 收据树（Receipt Trie）

### 🌳 交易树

- **内容**：当前区块中所有交易的列表。
- **结构**：Merkle Patricia Trie（MPT），键为交易在区块中的索引（0,1,2…），值为交易本身的 RLP 编码。
- **特点**：
  - 每个区块都有自己的交易树，只记录该区块交易。
  - 便于轻节点验证交易是否被打包。
- **限制**：
  - 无法直接查询历史交易（如过去10天与某智能合约相关的所有交易）。

------

### 🌳 收据树

- **内容**：每笔交易执行后的收据（Receipt）。
- **收据包含**：
  - 交易执行状态（成功/失败）
  - Gas 消耗
  - 日志（logs，事件记录）
- **结构**：与交易树一一对应，键为交易索引。
- **功能**：
  - 轻节点可以验证某笔交易的执行结果或事件是否发生。
  - 支撑 DApp 的事件订阅机制。

------

### 🔄 关系与特性

- **一一对应**：交易树的第 N 笔交易对应收据树的第 N 个收据。
- **状态驱动**：每笔交易执行后，会驱动账户状态的变化（状态树更新），类似状态机的操作。
- **查询方式**：只能根据交易在区块中的索引查找，无法跨区块、跨时间查询历史交易或事件。

## 布隆过滤器（Bloom Filter）

布隆过滤器是一种高效的概率型数据结构，用于检测某个元素是否可能存在于集合中。以太坊中，用于快速查找与特定智能合约或地址相关的交易。

------

### 🔹 在以太坊中的应用

1. **交易收据包含布隆过滤器**
   - 每笔交易执行完成后生成一个收据（Receipt）。
   - 收据中有布隆过滤器，用于记录交易相关的**事件、地址、合约调用信息**。
2. **区块头的总布隆过滤器**
   - 区块头中包含该区块所有交易布隆过滤器的**并集**。
   - 可以快速判断某个区块是否可能包含与特定地址或合约相关的交易。
3. **查询历史交易**
   - 查询过去10天中某个智能合约的相关交易：
     1. 检查区块头的布隆过滤器，看是否可能包含目标合约或地址。
     2. 若匹配，再查该区块内交易收据树的布隆过滤器。
     3. 定位到对应的交易及其收据。

------

### 🔹 布隆过滤器原理

1. **初始化位数组**
   - 假设有大小为 `m` 的位数组，初始所有位为 `0`。
2. **添加元素**
   - 对每个元素使用多组哈希函数（`k` 个哈希函数）。
   - 每个哈希函数生成一个整数，映射到位数组中的某个位置，将该位设为 `1`。
   - 多个哈希函数对应的位置都被置为 `1`，表示元素可能存在。
3. **验证元素是否存在**
   - 对要验证的元素，使用相同哈希函数计算对应位置。
   - **如果所有位都是 `1`** → 元素可能存在（存在误报的可能）。
   - **如果有任意一位为 `0`** → 元素**一定不存在**。

------

### 🔹 特性

- **高效**：比直接扫描交易或事件快得多。
- **节省空间**：用固定大小位数组记录大量元素。
- **允许误报**：可能提示元素存在但实际不存在，但**不会漏报**。
- **不可删除单个元素**：普通布隆过滤器无法删除元素（可用计数型布隆过滤器解决）。

---

## Ghost 协议（GHOST）解析

### 1. 分叉问题

- **比特币分叉**
  - 出块间隔：10 分钟
  - 分叉情况少，容忍度高
- **以太坊分叉**
  - 出块间隔：12 秒
  - 分叉频繁，铸币交易经常被取消
- **假设场景**
  - 分叉数量：3 条链
    - 中间链由矿池维护
    - 两条边链由个体矿工维护
  - 矿池算力约 30%，挖矿比例高 → 通常沿中间链继续挖
  - 矿池网络传输快 → 区块大概率先被接收
  - 个体矿工挖矿难度大

------

### 2. Ghost 协议初版机制

- **Uncle Block（叔块）奖励**
  - 挖矿失败（矿块被作废）也可获得奖励
  - 挖到矿块时，可将 uncle block 包含进新块
  - **奖励计算**：
    - Uncle block：奖励 = (7/8) × 3
    - 自身矿块：奖励 = (1/32) × 3 + 3 + gas fee
    - 可包含 2 个 uncle block → 自身奖励 = (1/32 × 3 × 2) + 3 + gas fee

------

### 3. 初版弊端

- 矿池出于自身利益，可能不包含其他矿工的 uncle block
- 超过 2 个 uncle block 无额外奖励

------

### 4. 改进方案

#### 4.1 多代 Uncle Block 包含

- 后续区块可以包含爷爷辈的 uncle block
- 奖励比例递减：
  - 当代 uncle block：7/8
  - 上代 uncle block：6/8
  - 依次递减
- **目的**：
  - 防止矿工趁分叉容易时疯狂挖矿，只坐等别人包含
  - 降低全节点维护历史 uncle block 的压力
  - 鼓励分叉及时合并

#### 4.2 Uncle Block 交易处理

- Uncle block 被包含时 **不执行其交易**
  - 避免交易冲突，例如：
    - A 账户余额 10
    - 两个区块中分别包含 A→B 10 和 A→C 10 的交易
    - 导致交易冲突，无效
- 挖矿区块只需验证 uncle block 难度是否符合要求
  - 不符合 → uncle block 无记账权

#### 4.3 分叉奖励策略

- **只打包第一个分叉**
- **目的**：
  - 鼓励分叉及时合并
  - 防止分叉攻击成本过低
  - 如果攻击失败 → 奖励作废
  - 如果攻击成功 → 写入公链



## 📦 挖矿算法

### 莱特币（Litecoin）：scrypt

- **工作原理**
  - 给定一个种子（如 *seed*），先计算其哈希并填充第一个位置。
  - 后续每个位置的值由前一个值继续哈希得到。
  - 在解谜过程中，需要从数组中取值来计算下一个位置，并不断迭代。
- **特点**
  - 必须保存整个数组，否则每次都得从头逐步重新计算。
  - **核心思路：增加内存需求**。这使得挖矿不再只依赖于纯计算力，而是对内存有较高要求。
  - 优点：对普通计算机更友好，降低了 ASIC 在早期的优势。
  - 缺点：对矿工来说是 **memory-hard**（内存硬需求），而对于一些 **轻节点**，内存可能不足以存储整个数组，导致运行困难。

### ⛏️ 以太坊挖矿算法 —— **Ethash**（废弃）

#### 1. 设计目标

- 抗 ASIC（至少在早期），让显卡也能公平挖矿。
- **Memory-hard**：大量依赖显存，防止单纯算力的暴力竞争。

#### 2. 工作原理

1. **生成数据集（DAG）**
   - 以太坊每个 **epoch（约 30,000 个区块 ≈ 5 天）** 会生成一个 **大数据集（DAG，Directed Acyclic Graph）**。
   - 矿工需要用到这个 DAG 来进行哈希计算。
2. **小数据集（Cache）**
   - DAG 由小数据集（Cache）扩展而来。
   - **轻节点**只需要保存 Cache，就能验证工作量证明。
     - 当矿工提交一个新区块时，轻节点会根据区块头里的信息（如 Nonce、MixHash）和 Cache，
        **动态生成 DAG 的部分数据**（不是整个 DAG）。
3. **哈希计算**
   - 矿工取区块头（含交易信息、Nonce 等），结合 DAG 中的数据进行多轮哈希运算。
   - 最终得到一个哈希值。
4. **难度比较**
   - 如果计算出的哈希值 **小于目标值（Target）**，说明矿工找到一个有效区块。
   - 广播区块 → 网络验证 → 链上确认。



### ⛓️ 以太坊权益证明（PoS）机制

#### 1. 基本概念

- **PoS（Proof of Stake，权益证明）**
  - 不依赖算力竞争，而是根据 **质押的代币数量** 来决定出块权。
  - 在以太坊中，成为验证者（Validator）需质押 **32 ETH**。
  - **安全性**：通过经济惩罚（Slashing）防止作恶或长时间离线。

------

#### 2. 共识流程

1. **质押（Staking）**
   - 节点需锁定 ≥ 32 ETH，才能参与共识。
2. **验证者选举（随机 + 权重）**
   - 系统随机挑选验证者作为 **区块提议者（Block Proposer）**；
   - 概率与质押 ETH 数量成正比。
3. **区块提议（Proposing）**
   - 提议者打包交易，生成新区块。
4. **验证与投票（Attestation）**
   - 其他验证者验证新区块并投票确认。
5. **达成共识（Finality）**
   - 当 ≥ 2/3 验证者投票支持时，区块获得 **最终性**（Finality），不可逆转。
6. **奖励与惩罚（Rewards & Slashing）**
   - 诚实验证者获得奖励；
   - 作恶或离线 → 扣减或罚没质押 ETH。

------

#### 3. 为什么切换到 PoS？

- **PoW 的问题**
  - 高能耗（以太坊 15 秒出块，能耗依旧巨大）。
  - 算力集中，易受 51% 攻击。
  - 挖矿设备依赖法币购买，缺乏系统内闭环。
- **PoS 的优势**
  - 攻击者必须持有 ≥ 50% 代币，买入会推高币价，攻击成本高。
  - 质押资金被锁定，降低双花风险。

------

#### 4. Casper FFG（Finality Gadget）

- **问题**：PoW 中区块缺乏“最终性”，可能被替换。需要一种机制，能明确判断某个区块是否“不可逆转”。
- **解决方案**：引入 **Casper FFG** 两阶段投票机制：
  - 每 **50 个区块** = 1 个 **Epoch**；
  - 两轮投票：
    1. **Prepare** → ≥ 2/3 验证者同意；
    2. **Commit** → ≥ 2/3 验证者再次确认；
  - 连续两个 Epoch 通过投票 → 区块获得 **Finality**。

------

#### 5. 验证者机制

- **任期制**：验证者周期性轮换。
- **激励与惩罚**：
  - 正常投票 → 奖励 ETH；
  - 离线、双签、乱投票 → Slashing，没收质押。
- **社区监督**：
  - 其他节点可举报验证者作恶；
  - 举报成功 → 举报者获奖励，恶意者受罚。

------

#### 6. 风险与挑战

- **两头下注（Nothing-at-Stake）**
  - 验证者可能在多个分叉上同时投票。
  - 若 ≥ 1/3 验证者双重下注 → 区块链可能分裂。
  - **解决方案**：Slashing 惩罚双签，增加作恶成本。