<h1 align="center">区块链理论 / BTC</h1>

<p align="center">
  <img src="https://img.shields.io/badge/Markdown-模板-blue.svg" />
  <img src="https://img.shields.io/badge/Version-1.0-green.svg" />
</p>
# 📚区块链理论 / BTC

---

## ✨ 密码学原理

📌 区块链的核心其实离不开密码学，它通过多种密码学原理来确保数据安全、交易可信、网络去中心化

### 🔥 为什么区块链需要加密
* 区块链的数据是公开透明的，为了保护隐私性和安全性因此需要加密
* 确保数据完整性以及验证身份

---

### 🔥 BTC是通过什么加密算法
💡 **SHA-256哈希算法**

- 将任意长度的输入映射成256位的输出
- 根据输出无法反推输入，只能通过穷举法
- 人为构造hash碰撞的概率很低，几乎不可能，因为有2^256种不同的输出

**使用场景**

- ✅上传文件：计算hash值，下载好后再计算一遍hash值，可以检测文件是否完整
- ✅比特币挖矿：计算hash(block header + 随机数) <= target，**nonce**需不断尝试

---

### 🔥 加密方式

#### 💡 对称加密从

双方通过安全渠道协商密钥，用于加密解密

#### 💡 非对称加密

* 公钥加密，私钥解密
* 用公钥加密的数据，**只能用对应的私钥解密**；
* 用私钥签名的数据，**只能用对应的公钥验证签名**。
* ✅加密场景
  * A给B转账，A用B的公钥加密，B用自己私钥解密
  * A给B转账，B用A的公钥验证数字签名

#### 💡 数字签名

✅确保交易未被篡改，验证发送者身份。

**流程A给B转账为例**

* A将交易信息、公钥，以及用私钥对交易信息哈希后生成的数字签名发送给B。
* B使用A的公钥**解密数字**签名，得到签名对应的哈希值 hash1。
* B对接收到的交易信息自行计算哈希值 hash2。
* 若 hash1 与 hash2 相同，则签名有效；否则说明交易被篡改。

---

## ✨ BTC的数据结构

<img src="img\比特币数据结构图.jpg" />

### 🔥 版本号

标识区块链协议的版本

### 🔥 父区块哈希值

📌修改任一区块**会导致后续所有区块的Hash指针失效**

### 🔥 时间戳

记录区块创建的时间

### 🔥 难度

用于工作量证明（POW）算法，决定挖矿的难度

### 🔥 随机数

挖矿时不断调整的随机值，用于找到满足难度目标的哈希值。

### 🔥 默克尔根

Merkle 树是一种**哈希树**结构，用于高效、可靠地验证大规模数据完整性。

#### 💡特性

* **叶子节点**：每个数据块的哈希值 H(data)

* **非叶子节点**：其左右子节点哈希拼接后再进行一次哈希：
  * H(parent) = H(H(left) + H(right))

* **根节点（Merkle Root）**：代表整个数据集合的唯一摘要。
* **图解**

<img src="img\默克尔树.png" alt="默克尔树" />

* **📌 快速验证交易是否正确**
  * 其中一个叶子节点修改了，那么沿着往上都会修改，最后Root也跟着修改

<img src="img\默克尔树判断交易是否存在.png" alt="默克尔树判断交易是否存在" />

#### ❓ 如何验证交易不在区块中

> 默克尔树无法验证原因
>
> * Merkle Proof **只能提供存在的路径**，即从某个叶子到根的哈希路径
> * Merkle树结构本身**不包含“所有可能交易”的信息**，它只对已包含的交易生成树

✅排序的默克尔树

<img src="img\排序的默克尔树.png" alt="排序的默克尔树" />

如果想验证10是否不在区块中，全节点返回9和11的Merkle 证明（证明它们确实存在于区块里）。

📌 **由于树是按照hash排序的，发现hash(10) 不在 hash(9) 和 hash(11)之间，那么不存在**

---