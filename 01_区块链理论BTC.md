<h1 align="center">区块链理论 / BTC</h1>

<p align="center">
  <img src="https://img.shields.io/badge/Markdown-模板-blue.svg" />
  <img src="https://img.shields.io/badge/Version-1.0-green.svg" />
</p>
# 📚区块链理论 / BTC

---

[TOC]

## ✨密码学原理

📌 区块链的核心其实离不开密码学，它通过多种密码学原理来确保数据安全、交易可信、网络去中心化

### 🔥 为什么区块链需要加密
* 区块链的数据是公开透明的，为了保护隐私性和安全性因此需要加密
* 确保数据完整性以及验证身份

---

### 🔥 BTC是通过什么加密算法
💡 **SHA-256哈希算法**

- 将任意长度的输入映射成256位的输出
- 根据输出无法反推输入，只能通过穷举法
- 人为构造hash碰撞的概率很低，几乎不可能，因为有2^256种不同的输出

**使用场景**

- ✅上传文件：计算hash值，下载好后再计算一遍hash值，可以检测文件是否完整
- ✅比特币挖矿：计算hash(block header + 随机数) <= target，**nonce**需不断尝试

---

### 🔥 加密方式

#### 💡 对称加密从

双方通过安全渠道协商密钥，用于加密解密

#### 💡 非对称加密

* 公钥加密，私钥解密
* 用公钥加密的数据，**只能用对应的私钥解密**；
* 用私钥签名的数据，**只能用对应的公钥验证签名**。
* ✅加密场景
  * A给B转账，A用B的公钥加密，B用自己私钥解密
  * A给B转账，B用A的公钥验证数字签名

#### 💡 数字签名

✅确保交易未被篡改，验证发送者身份。

**流程A给B转账为例**

* A将交易信息、公钥，以及用私钥对交易信息哈希后生成的数字签名发送给B。
* B使用A的公钥**解密数字**签名，得到签名对应的哈希值 hash1。
* B对接收到的交易信息自行计算哈希值 hash2。
* 若 hash1 与 hash2 相同，则签名有效；否则说明交易被篡改。

---

## ✨ BTC的数据结构

<img src="img\比特币数据结构图.jpg" />

### 🔥 版本号

标识区块链协议的版本

### 🔥 父区块哈希值

📌修改任一区块**会导致后续所有区块的Hash指针失效**

### 🔥 时间戳

记录区块创建的时间

### 🔥 难度

用于工作量证明（POW）算法，决定挖矿的难度

### 🔥 随机数

挖矿时不断调整的随机值，用于找到满足难度目标的哈希值。

### 🔥 默克尔根

Merkle 树是一种**哈希树**结构，用于高效、可靠地验证大规模数据完整性。

#### 💡特性

* **叶子节点**：每个数据块的哈希值 H(data)

* **非叶子节点**：其左右子节点哈希拼接后再进行一次哈希：
  * H(parent) = H(H(left) + H(right))

* **根节点（Merkle Root）**：代表整个数据集合的唯一摘要。
* **图解**

<img src="img\默克尔树.png" alt="默克尔树" />

* **📌 快速验证交易是否正确**
  * 其中一个叶子节点修改了，那么沿着往上都会修改，最后Root也跟着修改

<img src="img\默克尔树判断交易是否存在.png" alt="默克尔树判断交易是否存在" />

#### ❓ 如何验证交易不在区块中

> 默克尔树无法验证原因
>
> * Merkle Proof **只能提供存在的路径**，即从某个叶子到根的哈希路径
> * Merkle树结构本身**不包含“所有可能交易”的信息**，它只对已包含的交易生成树

✅排序的默克尔树

<img src="img\排序的默克尔树.png" alt="排序的默克尔树" />

如果想验证10是否不在区块中，全节点返回9和11的Merkle 证明（证明它们确实存在于区块里）。

📌 **由于树是按照hash排序的，发现hash(10) 不在 hash(9) 和 hash(11)之间，那么不存在**

---

## ✨ BTC协议

### 🔥 交易规则 (Transaction Layer)

交易是比特币的核心数据结构。

- **交易结构**：
  - 输入 (Input)：引用前一笔交易的输出。
  - 输出 (Output)：包含锁定脚本（scriptPubKey）和金额。

- **UTXO 模型**：

  - 所有未花费的输出 (Unspent Transaction Outputs) 组成了比特币的“账本”。

    > Account-based ledger 直接记录每个账户的余额和状态，交易通过更新这些状态来实现资产转移。以太坊、Solana、BSC 等智能合约平台普遍使用此模型。

- **验证规则**：

  - 输入必须引用有效且未花费的 UTXO。
  - 输入金额 ≥ 输出金额。
  - 交易大小、签名、锁定时间（nLockTime）、版本号等符合规则。

💡**举个例子**:**Alice转给Bob了2块钱**

<img src="img\UTXO.png" alt="UTXO" />

💡**输入输出如下**

![UTXO-输入输出](img\UTXO-输入输出.jpg)

📌 **验证规则**

1. **检查输入 UTXO 是否存在且未花费**
   * 从UTXO集合找，Alice的5 BTC输出，找不到或者被花过，则交易无效
2. **检查金额守恒**
   * 输入金额5 >= (2 + 3)
3. **检查签名**
   * 用Alice的公钥验证签名是否正确，确保Alice确实有权花费这笔钱
4. **执行脚本**
   * 解锁脚本（`scriptSig`） + 锁定脚本（`scriptPubKey`）拼接执行
   * 结果必须是 True，否则交易无效。
5. **更新 UTXO 集**
   * 删除旧的 5 BTC UTXO（标记为已花费）。
   * 新增2个UTXO：
     * 3BTC -> Alice
     * 2BTC -> Bob

---

#### ❓ **如何防止双花攻击？**

> 本质依赖 **UTXO 模型** + **区块链共识机制**。

------

##### 1. 场景描述

- A 账户（A 拥有一个 **5 BTC 的 UTXO**）。
- A 同时发起两笔交易：
  - **Tx1**：A → B **2 BTC**
  - **Tx2**：A → C **2 BTC**
- 两笔交易都引用了 **同一个 5 BTC 的 UTXO**。

------

##### 2. 节点验证过程

**当节点收到 Tx1：**

- 检查输入：UTXO(5 BTC) 存在，未花费 ✅
- 检查金额：5 ≥ 2 + 找零 ✅
- 验证签名 ✅
   ➡️ **Tx1 合法**，进入内存池 (mempool)。

**当节点收到 Tx2：**

- 输入引用的还是那个 5 BTC 的 UTXO。
- 但该 UTXO 已被 Tx1 占用（锁定）。
   ➡️ **Tx2 被判定为冲突交易 → 拒绝。**

⚠️ **注意**：不同节点收到交易的顺序可能不同。

- 先收 Tx1 的节点：保留 Tx1，拒绝 Tx2。
- 先收 Tx2 的节点：保留 Tx2，拒绝 Tx1。

------

##### 📌最终确认哪一笔？

取决于 **矿工打包区块** 的结果：

| 情况             | 链上确认结果 | 另一笔交易   |
| ---------------- | ------------ | ------------ |
| 矿工打包 **Tx1** | A → B 2 BTC  | Tx2 永远无效 |
| 矿工打包 **Tx2** | A → C 2 BTC  | Tx1 永远无效 |

------

✅ **结论**：

- 同一个 UTXO **只能被花费一次**。
- 最终确认权归于 **先进入区块并被全网共识的交易**。

#### 🔒交易双方身份与公钥验证机制

##### 1. 收款人如何提供公钥地址

- 在比特币网络中，收款人（如 **B 和 C**）需要 **主动提供自己的地址**（即公钥哈希）给付款人（A）。
- 如果某电商网站支持比特币支付，B 和 C 可以在网页上 **公开显示地址**，例如：
  - 生成二维码
  - 显示字符串地址
- 用户 A 扫码或复制后，即可向该地址转账。

------

##### 2. 区块链中的其他节点为什么要知道付款方的公钥

- 用于验证交易确实是 **由 A 签名授权的**；
- 决定是否将这笔交易 **转发 / 打包进区块**；
- 防止 **双重支付** 和 **伪造交易**，维护网络共识。

------

##### 3. 如何验证付款人的公钥确实属于自己

**场景：**

- 上一笔交易把 **3 BTC 转给 Alice**；
- 该交易的输出地址是 **Alice 的地址**（实质上是她 **公钥的哈希值**）。

**Alice 想花这笔钱时，必须提供：**

1. 她的 **公钥（PubKeyA）**；
2. 她对当前交易的 **签名（Sig）**。

**验证逻辑：**

- 节点根据 Alice 提供的公钥，计算 `HASH160(PubKeyA)`；
- 比对该结果是否等于上笔交易输出中的地址：
  - ✅ 相等 → 说明公钥正确，签名再验证通过 → 交易合法；
  - ❌ 不相等 → 公钥与原地址不匹配 → 交易无效（伪造）。

---

### 🔥 网络层协议 (P2P 网络)

#### 1. 新区块的产生与传播

1. 某个矿工挖出新区块。
2. 通过 P2P 网络，矿工向自己连接的邻居节点发送 **`inv` 消息（inventory）**。
3. 邻居节点收到 `inv` 后：
   - 检查本地是否已有该区块；
   - 如果没有，则发送 **`getdata` 请求**，获取区块的完整数据。

------

#### 2. 区块验证流程

节点收到完整区块后，会执行完整的验证：

- ✅ **区块头验证**
  - 工作量证明是否达标？
  - 难度是否正确？
- ✅ **区块链结构验证**
  - 是否引用了有效的前一区块？
  - 链条是否连续？
- ✅ **交易验证**
  - 每笔交易是否合法？
  - UTXO 是否存在且未花费？
  - 签名是否正确？
  - 是否存在双花？
  - 格式是否符合协议规范？

------

#### 3. 广播与全网同步

验证通过后：

- 节点会继续向自己的邻居节点发送 `inv` 消息；
- 形成 **雪球式广播**；
- 几秒到几十秒内，几乎所有节点都能同步到该新区块。

###  **🔥 共识规则 (Consensus Rules)**

在比特币网络中，所有节点必须遵循 **共识规则**，否则它们产生的区块或交易会被全网拒绝。
 这些规则的核心目标是：
 👉 保证区块链全网的一致性
 👉 防止作恶行为（如双花、伪造区块）

#### 1. 区块结构与验证规则

- **区块头（80字节）**：
   包含版本号、前区块哈希、Merkle Root（交易根）、时间戳、难度目标、Nonce。
- **区块体**：
   包含交易列表。
- **验证要求**：区块头格式必须正确，Merkle Root 必须与区块交易一致。

------

#### 2. 工作量证明 (Proof of Work, PoW)

- 区块哈希必须 **小于难度目标**。
- 计算 PoW 需要大量算力，保证攻击者无法轻易伪造区块。

------

#### 3. 难度调整

- 每 **2016 个区块**（约两周）自动调整难度。
- 目标：保持出块时间约 10 分钟。
- 避免因算力变化导致区块过快/过慢产生。

------

#### 4. 最长链原则

- 节点总是选择 **累计工作量最多** 的链作为主链（而不仅仅是“区块数最多”）。
- 确保在分叉时，全网最终会收敛到同一条链。

------

#### 5. 奖励规则

- 矿工通过打包区块获得：
  - 区块奖励（新区比特币）
  - 交易手续费
- 区块奖励每 **210,000 个区块**（约 4 年）减半，直到最终只剩手续费。

------

#### 与女巫攻击 (Sybil Attack) 的关系

**女巫攻击** 指的是攻击者创建大量虚假节点，企图影响网络共识。
 但在比特币中，单靠“多开节点”并不能控制网络，原因是：

1. **PoW 约束算力，而不是节点数量**
   - 共识的投票权重由算力决定，而不是节点数量。
   - 你可以运行 1000 个节点，但如果没有算力，仍然无法产生有效区块。
2. **最长链原则抵御伪造**
   - 即使攻击者用女巫节点“喊口号”，只要它们不能挖出更长的链，就不会被全网承认。
3. **奖励机制与成本**
   - 挖矿需要真实算力和电力投入，作恶（如双花）需要付出巨大成本。
   - 长期来看，遵守共识挖矿比攻击更有利可图。

------

✅ 所以：

- 共识规则保证了“谁算力多，谁有话语权”；
- 女巫攻击在比特币中基本无效，因为节点数量 ≠ 共识权重；
- 唯一有效的攻击是 **算力攻击**（如 51% 攻击），而不是传统的女巫攻击。

---

## ✨ 手续费

### 🔥 为什么有手续费

激励矿工优先处理你的交易

* 区块大小1M，每笔交易大概250个字节，因此也就4000个交易左右，是有限的
* 当网络拥堵时，矿工会优先打包 **手续费高的交易**
* 如果你不给手续费 → 可能一直被忽略
* 手续费 = **用户竞争区块空间的“出价”**

#### 💡 比特币奖励会逐渐减半直至为零

![比特币每4年减半](img\比特币每4年减半.png)

❓ **为什么每4年减半**

* 比特币设计的是：**每 210,000 个区块**，比特币区块奖励就会减半

* 平均 **每 10 分钟** 出一个区块

  所以每天约出块 6 × 24 = 144 个

  每年约出块：144 × 365 ≈ 52,560 个

  4 年出块数量：52,560 × 4 ≈ 210,240

* 所以**210,000 区块 ≈ 4 年**，用区块数控制比“按时间”更精准稳定

📉 区块奖励减半意味着：手续费将逐渐成为矿工**唯一的收入来源**。

❓ **比特币上限2100W个原因**

![比特币总发行量](img\比特币总发行量.png)

#### 💡 防止垃圾交易刷爆网络

如果没有手续费：

- 任何人都可以无限提交垃圾交易 → 占用区块空间，拖慢全网效率。

有了手续费：

- 用户提交交易必须“付出代价”，能有效防止滥用。

### 🔥 手续费是怎么给矿工的

手续费 **不是额外支付**，而是

```
手续费 = 输入金额总和 - 输出金额总和
```

矿工在构造 **coinbase 交易**（区块第一笔交易）时，会将 **出块奖励 + 所有交易手续费** 一起写给自己：

```
coinbase output：
→ 6.25 BTC（出块奖励）
+ 0.01 BTC（手续费）
= 6.26 BTC（全部发给矿工地址）
```

## ✨ BTC网络

- 比特币网络是一个 **去中心化的 P2P 支付网络**，基于区块链技术构建，**所有节点都是平等的**。

  ------

### 🚀 新节点启动流程

1. **读取本地节点列表**：从本地数据库读取上次保存的 peer list。
2. **连接种子节点**：若本地没有可用节点，则连接硬编码或配置好的 Seed Nodes。
3. **请求节点地址**：向 Seed Node 发送 `getaddr` 消息，请求更多节点信息。
4. **接收节点列表**：Seed Node 回复 `addr` 消息，返回多个活跃节点地址。
5. **建立连接**：新节点尝试与这些地址建立连接，成功后正式进入比特币 P2P 网络。

------

### 💸 交易转发流程

#### 1. 发起交易

- 用户通过钱包软件（如 **Bitcoin Core**、**Electrum**）创建交易。
- 钱包使用私钥进行 **数字签名**，确保交易只能由持币人授权。

#### 2. 广播交易

- 钱包将签名后的交易发送给所连接的全节点。
- 全节点接收后进行 **基础验证**：
  - ✅ 交易格式是否合法
  - ✅ 数字签名是否有效
  - ✅ 输入引用的 UTXO 是否尚未被花费（检查 mempool + 本地 UTXO 集）

#### 3. 存入内存池（mempool）

- 验证通过的交易会被加入本地 **mempool（内存池）**。
- mempool 存储的是：**未被打包进区块但合法的交易**。
- 矿工会从 mempool 挑选交易，通常优先选择 **手续费高的交易**。

#### 4. 防止双花（Double Spending）

- 每个节点的 mempool **只允许同一个 UTXO 被使用一次**。
- 若新交易引用了已被使用的 UTXO，会被判定为“双花”，通常直接拒绝。

#### 5. 向其他节点传播（Gossip 协议）

- 节点通过 `inv`（inventory）消息通知 peer：“我有新交易”。
- 若 peer 没有该交易，会发起 `getdata` 请求。
- 一旦收到完整交易，peer 验证并存入 mempool，然后继续广播给其他节点。

---

## ✨ BTC挖矿

### ❓ 如果大量用户挖矿，随机数不够怎么办

在比特币挖矿中，矿工需要不断改变区块头中的数据，计算哈希值，直到找到 **小于目标难度值的哈希**。
 关键字段就是 **nonce**。

#### ⚡ 为什么会“随机数不够”

- 区块头中的 `nonce` 字段是 **4 字节（32-bit）**，范围是：

```
0 ～ 2^32 - 1  ≈ 42 亿
```

* 现代矿机的算力可以在 **几秒钟内耗尽整个 nonce 空间**。
* 如果只依赖 `nonce`，很快就会“数完了”，无法继续尝试。

#### 🛠 解决方法：修改 coinbase 交易中的 **extraNonce**

除了 `nonce`，矿工还可以通过改变 **coinbase 交易** 来扩展尝试空间：

1. **extraNonce 的引入**
   - 矿工在 coinbase 交易中加入一个额外字段 **extraNonce**。
   - 修改 extraNonce → coinbase 交易内容变了。
   - coinbase 交易改变 → **Merkle Root 改变** → **区块头 Hash 改变**。

2. **工作流程**

```python
for extraNonce in range(...):           # 外层循环，不断修改 coinbase
    for nonce in range(0, 2^32):        # 内层循环，遍历常规 nonce
        hash = sha256(blockHeader)
        if hash < target:
            return block   # 找到合适区块

```

3. **效果**

- 相当于把“42 亿次尝试空间”扩展成了几乎无限次。
- 比如 extraNonce 用 **64-bit** 表示，就有 2^64 ≈ 1.8 × 10^19 种可能性，远远够用。

### ⛏️ 挖矿的特性

#### 🎲 伯努利试验特性

挖矿过程可以抽象为 **伯努利试验**：

- 只有两个结果：
  - ✅ 成功（找到合格区块）
  - ❌ 失败（哈希不满足目标）
- 每次尝试成功的概率为 **$p$**，失败概率为 **$1-p$**。
- 每次尝试 **相互独立**，前一次失败不会提高或降低下一次的成功率。

👉 举例：

- 若某矿工的算力占全网 **1%**，则期望平均每 **100 个区块**能挖到 1 个。
- 由于比特币平均 **10 分钟出一个区块**，所以该矿工期望等待时间 ≈ **100 × 10 = 1000 分钟**。

------

#### ⏳ 无进展积累性（Progress-Free）

比特币挖矿是 **无进展积累的**：

- 若在 10 分钟内没有人找到新区块 → 所有计算尝试作废，下一个区块必须 **重新开始**。
- 挖矿过程 **没有“累积进度”**，每轮都是全新独立的伯努利试验。

------

##### ⚖️ 防止算力过强者压倒性获利

假设有两位矿工：

- A 的算力是 B 的 **10 倍**。

在 **Progress-Free 挖矿机制**下：

- A 和 B 的中标概率 ≈ **10:1**，与算力成正比。

如果允许“进度累积”并延续下一轮（非 Progress-Free）：

- A 因为算力更强，能保留更多“未完成的工作量”，效率会远超 10 倍。
- 结果是 **算力强者获得不成比例优势**，破坏了比特币追求的 **去中心化公平性**。

---

### 🔒 比特币通过挖矿获得安全性

#### 🪙 伪造奖励

- 假设记账权落在一个恶意矿工 **M** 手中：
  - M 在区块中伪造一笔交易（如 `A → M` 的盗币交易）。
  - 其他诚实节点不会接受该区块。
  - M 不仅无法盗币，还会损失该区块的 **奖励**（出块奖励 + 手续费）。

👉 机制：**不诚实的区块不会被认可，恶意矿工反而会亏损奖励。**

#### 💸 双花攻击（Double Spending）

**基本原理**：每个交易输入（input）必须引用一个尚未花费的 UTXO。

- M 将 `UTXO1` 转给 A → `UTXO1` 被标记为 **已花费**。
- 如果 M 试图再次使用 `UTXO1` → 系统会认定为 **双花**，正常情况下不被接受。

**攻击方式**：

1. M 构造两条链：
   - 链1：包含交易 **M → A**（A收到钱）。
   - 链2：由 M 主导，不包含该交易（M 伪造 **M → M**）。
2. 如果 A 在链1 的交易确认后发货，而 M 后来挖出一条更长的分叉链（链2），且被全网接受为主链：
   - 链1 的交易会被回滚，相当于从没发生过。
   - A 付出实际代价却没收到比特币，M 完成了双花攻击并获利。

#### 🛡️ 防范机制

- 在比特币中，交易被写入区块只是第一步。
- **后续新增区块数量（确认数）决定交易的安全性**：
  - 1 个确认 → 较容易被回滚
  - 确认数越多 → 回滚难度越大

📌 官方建议：

- **6 个确认（约 1 小时）** 被认为是非常安全的。
- 想要回滚 6 个区块，攻击者必须重写这 6 个区块 → 随着确认数增加，攻击成本 **指数级上升**，收益迅速下降。

### 🕳️ 自私挖矿（Selfish Mining）

#### 📌 攻击原理

矿工（或矿池）在挖到新区块后，**不立即广播**，而是：

1. 先将区块 **私下保留**，不告诉全网。
2. 继续在这个“私链”上挖下一个区块。
3. 如果私链领先于公共链，就将其公布，迫使全网切换到攻击者的链。

------

#### ⚡ 攻击效果

- 自私矿工获得更多的 **区块奖励**：
  - 因为他们能让自己的链领先并最终成为主链。
- 诚实矿工的算力被浪费：
  - 因为他们在被弃用的链（孤块）上白白挖矿。
- 结果：
  - 自私矿工的 **实际收益 > 算力占比**，形成 **不公平优势**。

------

#### 🔑 攻击前提

- 自己（或所在矿池）的算力必须 **足够强**：
  - 算力占比越高，自私挖矿越可能成功。
  - 一般认为，当矿工控制算力超过 **33%** 时，自私挖矿就可能比诚实挖矿更有利可图。

### ⚡ Zero Confirmation（零确认交易）

#### 📌 定义

零确认交易 = 一笔 **已经广播到比特币网络**，但 **尚未被矿工打包进区块** 的交易。

- 状态：确认数 = **0**
- 风险：随时可能被替换或丢弃

------

#### 🔐 安全性分析

##### 1. 双花攻击（Double Spending）

- 用户可以同时广播另一笔交易，使用相同的 UTXO 支付给别的地址（甚至是自己）。
- 如果矿工最终选择了另一笔交易 → 原先支付给商家的交易就会 **失效**。

##### 2. RBF 攻击（Replace By Fee）

- 如果交易启用了 **RBF**（可被手续费替换）：
  - 用户可用 **更高手续费** 替换已广播的交易。
  - 替换后的交易内容可能完全不同，例如：
    - 原交易：`M → 商家`
    - 替换交易：`M → M 自己`

------

#### ❓ 为什么电商有时接受零确认交易

- 某些零售商（尤其是线下即时消费场景，如咖啡厅、便利店）为了提升体验：
  - 无法让顾客等 **10 分钟确认** 才交付商品
  - 因此会冒险接受零确认支付

------

#### ✅ 解决与防范方式

1. **设置等待时间**
   - 至少等待交易在网络中广泛传播到大部分节点
2. **拒绝 RBF 交易**
   - 不接受标记为 RBF-enabled 的交易
3. **判断用户信誉**
   - 对老用户或小额支付容忍零确认
   - 对陌生用户或大额支付要求确认
4. **确认数要求**
   - 发货前至少等待 **1~2 个区块确认**
   - **6 个确认（约 1 小时）** 被认为非常安全

### 挖矿难度

比特币网络每 **2016 个区块**进行一次难度调整（约 2 周）。

#### 为什么是两周 2016 个区块

- 平均 **10 分钟 1 个区块**
- **1 小时 ≈ 6 个区块**
- **1 天 ≈ 144 个区块**
- **14 天（两周） ≈ 2016 个区块**

所以，比特币设计者规定：**每挖出 2016 个区块后，自动调整难度**，以保证长期维持“10 分钟 1 个区块”的出块速度。

------

#### 挖矿核心公式

区块头哈希计算：

```python
hash = SHA256(SHA256(版本号 + 上一区块哈希 + Merkle 根 + 时间戳 + 难度目标 + nonce))
```

要求：

```python
SHA256(SHA256(Block Header)) < Target
```

即：哈希值必须小于 **目标值（Target）**，矿工才能“成功挖矿”。

#### 难度调整公式

比特币协议中，新的目标值计算方式是：

```
new_target = old_target × (实际耗时 / 20160 分钟)
```

> 20160 分钟 = 2016 个区块 × 10 分钟

- 如果区块生成速度 **快于预期**（耗时 < 20160 分钟），说明算力上升 → **难度上调**（挖矿更难）。
- 如果区块生成速度 **慢于预期**（耗时 > 20160 分钟），说明算力下降 → **难度下调**（挖矿更容易）。

#### 难度调整限制

为避免算力剧烈波动导致难度大幅震荡，比特币协议规定：

- **单次最多降低到 25%**（难度最多下降 4 倍）
- **单次最多提高到 400%**（难度最多上升 4 倍）

### ⏱️ 如果每秒出一个区块，会造成什么影响

#### 1. 区块链增长速度过快，节点存储压力倍增

- 出块速度太快会导致链数据急剧膨胀。
- 节点需要更多存储空间和带宽，去中心化难度增加。

#### 2. 频繁分叉

- 区块网络传播时间大于 1 秒。
- 出块过快会出现 **两个矿工几乎同时挖出区块**，导致分叉频繁。
- 大量孤块出现，主链选择效率下降。

#### 3. 确认数不再安全

- 传统比特币建议等待 **6 个区块确认（约 1 小时）** 才安全。
- 如果 1 秒出块，6 个区块只需 **6 秒**，但链频繁分叉 → 确认数不稳定。
- 攻击者更容易发起 **链重组或双花攻击**，交易安全性下降。

#### 4. 算力浪费增加，挖矿成本提升

- 频繁分叉导致大量区块被废弃（孤块）。
- 矿工算力和电力投入浪费严重。
- 挖矿收益下降，矿工积极性降低。

### 🖥️ 全节点 & 轻节点

#### 1. 全节点（Full Node）

- **数据保存**：完整保存区块链数据，自己独立验证所有交易。
- **UTXO 管理**：在内存中维护 **未花费交易输出（UTXO）集合**，用于快速验证交易合法性。
- **链选择规则**：遵循 **最长链（最大工作量链）原则**，始终跟随最长的合法链。
- **特点**：资源消耗高，但安全性和独立性最强。

#### 2. 轻节点（Light Node / SPV Node）

- **数据保存**：只保存区块头，不保存完整区块数据。
- **交易验证**：依赖全节点，通过 **Merkle 证明** 验证与自己相关的交易是否包含在某个区块中。
- **链选择规则**：只能根据区块头的链长判断哪条是最长链，但无法独立验证区块合法性。
- **特点**：资源消耗低，但依赖性强，安全性不如全节点。

### ⛏️ 矿池（Mining Pool）

#### 📌 为什么会有矿池

- 比特币挖矿竞争激烈，单个矿工挖到区块的概率非常低。
- 矿池让矿工 **合力挖矿**，按算力贡献分配奖励，提高稳定收入。

------

#### 🏗️ 矿池的基本结构

1. **矿池服务器（Pool Server）**
   - 统一分配挖矿任务。
   - 接收矿工提交的工作成果。
   - 管理矿工奖励支付。
2. **矿工客户端（Miner Client）**
   - 接收矿池分配的挖矿任务。
   - 执行哈希计算，尝试找到有效结果并提交给矿池。

------

#### ⚙️ 矿池运作机制

1. **区块模板生成**
   - 矿池服务器生成候选区块模板（包含部分交易 + coinbase 交易）。
2. **任务分发**
   - 矿池分发简化挖矿任务给矿工（目标难度低于网络难度），方便矿工频繁找到 **Share**。
3. **Share 提交**
   - 矿工不断尝试不同的 **Nonce**，找到满足 share 难度的哈希后提交给矿池。
4. **算力统计**
   - 矿池收到 share 后，记录矿工的算力贡献。
5. **区块发现与广播**
   - 如果某矿工找到符合 **比特币网络真实难度**的合法区块，矿池广播该区块并领取奖励。
6. **奖励分配**
   - 按矿工提交的 share 数量和质量分配奖励，实现收益共享。

### 🔍 如何验证全节点的某个账户余额是否正确

#### 1️⃣ 构建 UTXO Merkle Tree

- 全节点根据当前 **UTXO 集** 构建一个 **Merkle Tree**。
- 将 **UTXO Merkle Root** 的哈希写入 **coinbase 交易**（例如写入 `scriptsig`）。

------

#### 2️⃣ 轻节点验证余额

- 轻节点收到全节点提供的某地址的 **UTXO 列表**（余额信息）后：
  1. 使用 **Merkle Proof** 验证该 UTXO 是否确实存在于 UTXO Merkle Tree 中。
  2. 通过验证 Merkle Proof 的正确性，可以确认该地址余额的准确性。

------

#### 3️⃣ 与区块头关联

- 将 UTXO Merkle Root 放入 coinbase 交易后：
  - 会影响交易的 **Merkle Tree 根**。
  - 进而影响 **区块头的 Merkle Root**。
- 这样，UTXO 的状态就和区块链的整体状态紧密绑定，保证验证可靠性。

---

## ✨ BTC脚本

上一笔交易和本次交易的输入输出

![比特币脚本](img\比特币脚本.png)

### 🔑 P2PK（Pay to Public Key）

#### 📌 定义

- 比特币最早期的付款脚本形式之一。
- 表示“支付给某个公钥”。
- **特点**：
  - 输出脚本中直接包含收款人的 **公钥**。
  - 花费这笔钱时，必须提供一个有效签名，该签名可被输出脚本中的公钥验证。

------

#### 📝 例子

假设 **A 向 B 转账 1 BTC**，B 提供自己的 **公钥**（而不是地址）作为收款方式。

##### 1️⃣ 输出脚本（锁定脚本，Output Script）

```
<PubKey_B> CHECKSIG
```

- 含义：花费这笔钱需要一个 **有效签名**，可被 `<PubKey_B>` 验证。

##### 2️⃣ 输入脚本（解锁脚本，Input Script）

```
PUSHDATA(Sig_B)
```

- 含义：B 想花这笔钱，提供用 **私钥生成的签名**。

------

#### ⚙️ 流程

1. A 构建交易，输出脚本为 `<PubKey_B> CHECKSIG`。
2. B 想花这笔钱时，用私钥签名，将签名放入输入脚本。
3. 节点验证时，将输入脚本和输出脚本拼接执行：

```
<Signature_B> <PubKey_B> CHECKSIG
```

4. 如果签名通过验证，交易被网络接受。

------

#### 🔐 理解

- 当你收到比特币时，相当于得到一个 **“锁”**。
- 想花这笔钱时，必须提供对应的 **“钥匙”（私钥签名）** 来解锁。

### 🔑 P2PKH（Pay to Public Key Hash）

#### 📌 定义

- 比特币中最常见的交易类型。
- 输出脚本中写入 **收款人的公钥哈希（PubKeyHash）**。
- 只有掌握对应 **私钥** 的人才能花费这笔钱。

------

#### 📝 例子

假设 **A → B → C**，这里分析 **B 转给 C 的交易**。

##### 1️⃣ 输出脚本（锁定脚本，Output Script）

```
DUP                 // 复制栈顶元素（公钥）
HASH160             // 对公钥进行 HASH160（SHA256 → RIPEMD160）
PUSHDATA(PubKeyHash) // 收款人的公钥哈希
EQUALVERIFY         // 校验公钥哈希是否与目标一致
CHECKSIG            // 验证公钥和签名是否匹配
```

- **锁定脚本**：指的是上一笔交易的输出，本次交易的付款人需要解锁。

------

##### 2️⃣ 输入脚本（解锁脚本，Input Script）

```
PUSHDATA(Sig)     // 付款人使用私钥对交易签名
PUSHDATA(PubKey)  // 付款人的公钥
```

------

#### ⚙️ 验证流程

1. 将输入脚本压入栈：

```
PUSHDATA(Sig)
PUSHDATA(PubKey)
```

1. 执行输出脚本：

```
DUP                 // 复制栈顶公钥
HASH160             // 对复制的公钥做 HASH160
PUSHDATA(PubKeyHash)// 压入输出脚本中目标公钥哈希
EQUALVERIFY         // 验证哈希是否一致
CHECKSIG            // 用公钥验证签名有效性
```

1. 若所有操作通过验证，交易有效，网络接受支付。

------

#### ✅ **理解**

- P2PKH 通过“公钥哈希 + 签名验证”机制，确保只有持有对应私钥的人才能花费比特币。
- 这也是比特币中最常用的支付方式，兼顾安全性与隐私性。

### 🔐 P2SH（Pay to Script Hash）

#### 📌 定义

- 资金被锁定在一个 **脚本（Script）** 中。
- 只有满足脚本条件的人才能花费这笔资金。
- 常用于 **多重签名（Multisig）** 或复杂支付条件。

------

#### 📝 例子

假设有 **5 个合伙人（A, B, C, D, E）**，规则：

> 必须任意 **3 个合伙人签名** 才能提取资金。

##### 1️⃣ 创建 Redeem Script（赎回脚本）

```
3 <PubKeyA> <PubKeyB> <PubKeyC> <PubKeyD> <PubKeyE> 5 OP_CHECKMULTISIG
```

- `3`：需要 3 个签名
- `5`：总共 5 个公钥
- `OP_CHECKMULTISIG`：比特币内置的多签验证指令

##### 2️⃣ 生成 P2SH 地址

1. 对 **Redeem Script** 执行 `HASH160`（SHA256 → RIPEMD160）。

2. 得到 P2SH 地址，例如：

   ```
   3QJmV3qfvL9SuYo34YihAf3sRCW3qSinyC
   ```

3. 别人向你转账时，就使用这个地址。

------

#### 🏦 锁定资金（Output Script）

```
OP_HASH160 <redeemScriptHash> OP_EQUAL
```

- 表示资金锁定在 **脚本哈希** 上。
- 只有提交脚本原文并且执行结果为 `true`，才能花费资金。

------

#### 🔓 解锁资金（Input Script）

- 花钱时必须提供：
  1. `OP_0`（占位符，用于 CHECKMULTISIG 的历史 bug）
  2. 3 个签名（Signature1、Signature2、Signature3）
  3. Redeem Script（脚本原文）

------

#### ⚙️ 验证流程

##### **第一阶段：验证脚本哈希**

1. `OP_0` → 占位
2. `PUSHDATA(Signature1)`
3. `PUSHDATA(Signature2)`
4. `PUSHDATA(Signature3)`
5. `PUSHDATA(RedeemScript)` → 压入栈
6. `HASH160` → 对 Redeem Script 计算哈希
7. `PUSHDATA(redeemScriptHash)` → 输出脚本中的哈希
8. `OP_EQUAL` → 比较两者是否相等

##### **第二阶段：执行 Redeem Script（多签验证）**

- 栈中已有：

  ```
  OP_0, Signature1, Signature2, Signature3
  ```

- 加上 Redeem Script：

  ```
  3 <PubKeyA> <PubKeyB> <PubKeyC> <PubKeyD> <PubKeyE> 5 OP_CHECKMULTISIG
  ```

- `OP_CHECKMULTISIG` 会验证：

  - 3 个签名是否对应 5 个公钥中的任意 3 个

- 若合法 → 返回 `true`，交易生效

------

✅ **总结**：
 P2SH 将复杂支付条件封装成 **脚本哈希地址**，用户只需知道哈希即可收款，而花费资金时必须提供 **脚本原文 + 满足条件的签名**，提高灵活性和安全性。

------

### 🔥 Proof of Burn（燃烧证明）

#### 📌 定义

- 通过 **销毁某种有价值的加密资产**（通常是币），换取未来挖矿或网络参与权利。
- “烧掉”手里的币以换取系统信任，表明长期参与的诚意。
- 系统据此赋予出块权利或奖励。

------

#### ⚙️ 原理

1. 用户将一定数量的代币（如 BTC）发送到 **无法使用的黑洞地址**（无私钥地址）。
2. 交易被永久记录在区块链上，**无法再次花费** → 即完成燃烧。
3. 系统根据 **燃烧数量和时间**，分配挖矿权或奖励。

---

## ✨ BTC分叉

### ⚠️ State Fork（状态分叉）

#### 📌 定义

- 当两个或多个节点对 **区块链的状态**（如账户余额、合约状态等）产生 **不一致看法**，就会形成 **状态分叉**。
- 注意：**状态分叉 ≠ 区块分叉**，它是节点对“链当前状态”的不同共识。

------

#### 📝 特点

- 通常由以下原因导致：
  - 客户端实现差异
  - 软件错误
  - 节点升级不同步
- 典型例子：
  - 以太坊某次升级中，一部分节点按新规则运行，另一部分未更新，导致对同一区块的处理结果不同 → 形成 state fork。

------

#### ⚠️ 影响

- 极其危险，会导致网络分裂。
- 可能破坏资产一致性。
- 常发生在 **硬分叉** 或重大升级时，例如：
  - DAO Hack 后的 **以太坊（ETH）与以太坊经典（ETC）** 分裂。

### ⚠️ Forking Attack（分叉攻击）

#### 📌 定义

- 恶意节点 **故意制造区块链分叉** 来达到特定目的的攻击方式。
- 常见目标：获得额外奖励或进行 **双花攻击（Double Spending）**。

------

#### 📝 常见类型

##### 1️⃣ Double Spending（双花攻击）

- 攻击者先发布一笔交易到网络。
- 随后在自己分叉的链上 **回滚这笔交易**，实现重复使用相同的 UTXO。
- 结果：原交易被作废，而攻击者可能获得实物或收益。

##### 2️⃣ Selfish Mining（自私挖矿）

- 攻击者挖出新区块后 **不立即广播**。
- 积累多个块形成私链。
- 当主链发布新区块时，攻击者 **突然发布自己的长链**，试图替换主链。
- 目的：获取 **超过其算力比例的额外区块奖励**。

### ⚠️ Deliberate Fork（蓄意分叉 / 有意分叉）

#### 1️⃣ Hard Fork（硬分叉）

- **定义**：不向后兼容，未升级节点会被分离到旧链上。

##### 📝 场景示例

- 原规则：比特币区块最大为 **1MB**
- 升级后：新规则允许 **最多 4MB 区块**
- **多数矿工升级** → 支持 4MB 区块
- **少数未升级节点** → 仍使用旧协议，只接受最大 1MB 区块

##### 🔹 会发生什么

- 新旧节点对“有效区块”判断标准不同
- 矿工打包大于 1MB 区块 → 老节点拒绝
- 新节点和老节点在不同链上继续前进 → **永久分叉（Hard Fork）**

##### ⚠️ 双花风险

- 链分叉时（如区块 #600,000）：
  - 链A（原链）
  - 链B（新链，规则不同）
- 区块 #600,000 之前的所有地址、UTXO、私钥、余额相同
- 如果在链A上发起交易签名，该交易 **可能在链B上也被验证成功** → 双花可能性

------

#### 2️⃣ Soft Fork（软分叉）

- **定义**：向后兼容，未升级节点仍能参与验证新区块。

##### 📝 场景示例

- 新区块最大 0.5MB，旧节点允许 1MB
- 新产生的区块 ≤ 0.5MB → 对旧节点仍合法
- 旧节点可以继续接收新区块 → 保持同一条链

##### 🔹 P2SH 是软分叉示例

- 老节点只看 `OP_HASH160 OP_EQUAL` → 输出合法，不改变验证逻辑
- 新节点增加对 **赎回脚本解析和验证**
- 新规则是旧规则的子集 → 旧节点仍接受新节点生成区块 → **软分叉**

------

#### 3️⃣ 真实案例

- **以太坊 DAO 事件**：
  - 为追回资金进行一次 deliberate fork
  - 结果：形成 **以太坊（ETH）** 与 **以太坊经典（ETC）**

------

✅ **理解**：

- **硬分叉**：不兼容，形成永久链分裂
- **软分叉**：兼容旧节点，不会破坏链的一致性
- Deliberate Fork 通常用于升级规则或纠正重大事件，但风险高，可能产生双花或资产分裂。

---

## ✨ BTC匿名性

### 1️⃣ 实名制（KYC）交易所

- 用户信息（身份证、手机号、银行卡、地址）与交易记录绑定
- 一旦链上地址与交易所的充值/提现地址匹配 → 可识别用户身份
- 链上其他相关地址也可能被 **顺藤摸瓜** 追踪

------

### 2️⃣ 输入合并分析（Input Clustering）

- 如果交易输入包含多个地址，例如：

```
Inputs:
- addrA
- addrB
```

- 链上分析工具（如 Chainalysis、Elliptic）会认为 **addrA 和 addrB 很可能属于同一人**
- 原因：控制这些地址的私钥才能一起签名交易

------

### 3️⃣ 找零地址泄露（Change Address Leak）

- 情境：向某人支付 0.5 BTC，但钱包有 1 BTC 的 UTXO
- 系统自动生成“找零地址”，把剩余 0.5 BTC 转回
- 链上分析者可推测出 **哪一个是找零地址**
- 通过分析找零地址，逐步建立用户的 **地址网络图谱**

------

✅ **总结**：

- 比特币并非真正匿名，而是 **伪匿名（pseudonymous）**
- 地址的关联性、交易模式和 KYC 信息都可能暴露用户身份
- 使用混币服务、CoinJoin 等技术可提高隐私，但无法完全隐藏链上行为

---

## ✨ BTC问答

- ### 1️⃣ 收款人不在线

  - 交易广播后，全网节点接收并验证（签名有效性、UTXO 是否存在等）
  - 验证通过后，交易进入各节点的 **Mempool** 等待矿工打包
  - 收款人是否在线 **不影响交易完成**

  ------

  ### 2️⃣ 收款地址可能是新生成的

  - 新地址可能从未在链上使用过
  - 没有历史交易记录也不会影响收款

  ------

  ### 3️⃣ 私钥丢失

  - 无法签署交易 → 资产无法花费
  - 资产“锁死”，仍在区块链上，但不可用
  - 不可恢复：区块链没有中心化机构可以找回

  ------

  ### 4️⃣ 转账写错地址

  - 无法强制追回资金
  - 只能与收款方协商

  ------

  ### 5️⃣ OP_RETURN

  - Bitcoin Script 中的操作码，允许在交易输出嵌入**不可花费的数据**
  - OP_RETURN 输出无法花费，任何尝试都会被视为无效

  ------

  ### 6️⃣ 矿工随机值安全性

  - 成功 nonce 只对特定区块头有效
  - 其他矿工无法复用，尤其因为交易顺序、Coinbase 地址不同

  ------

  ### 7️⃣ Hash 指针在区块链中的传播机制

  - 全节点维护键值数据库（key = 区块哈希，value = 区块内容）
  - 查询方法：
    1. 获取最新区块的哈希
    2. 查询对应区块内容
    3. 读取前一区块哈希 → 递归查询
    4. 直到创世区块

  ------

  ### 8️⃣ 多人共享账户

  - 单独截断私钥安全性低
    - 例如 4 人共享，3 人可以尝试 2^64 次破解
  - 安全做法：使用 **多重签名（MultiSig）**
  - 丢失密钥会导致 UTXO 膨胀，增加全节点负担

  ------

  ### 9️⃣ 比特币如何绕过分布式共识的不可能结论

  - **异步模型 + 最终一致性**
    - 网络消息传播延迟
    - 不强求实时共识，通过 **最长链规则**实现最终一致性
  - **概率共识（PoW）**
    - 矿工独立挖矿，无固定领导者
    - 分叉可能存在，但最终概率上形成唯一链
  - **经济激励与计算难度**
    - 篡改历史成本极高（重做 PoW）
    - 节点遵守协议有经济合理性保障